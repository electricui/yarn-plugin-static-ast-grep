/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-static-ast-grep",
factory: function (require) {
var plugin=(()=>{var me=Object.create;var O=Object.defineProperty;var fe=Object.getOwnPropertyDescriptor;var de=Object.getOwnPropertyNames;var ge=Object.getPrototypeOf,he=Object.prototype.hasOwnProperty;var l=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var N=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),Pe=(e,t)=>{for(var r in t)O(e,r,{get:t[r],enumerable:!0})},A=(e,t,r,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of de(t))!he.call(e,o)&&o!==r&&O(e,o,{get:()=>t[o],enumerable:!(n=fe(t,o))||n.enumerable});return e};var ye=(e,t,r)=>(r=e!=null?me(ge(e)):{},A(t||!e||!e.__esModule?O(r,"default",{value:e,enumerable:!0}):r,e)),Fe=e=>A(O({},"__esModule",{value:!0}),e);var V=N((Ze,T)=>{"use strict";var z=()=>process.platform==="linux",x=null,we=()=>{if(!x)if(z()&&process.report){let e=process.report.excludeNetwork;process.report.excludeNetwork=!0,x=process.report.getReport(),process.report.excludeNetwork=e}else x={};return x};T.exports={isLinux:z,getReport:we}});var _=N((Je,H)=>{"use strict";var G=l("fs"),ke="/usr/bin/ldd",Le=e=>G.readFileSync(e,"utf-8"),ve=e=>new Promise((t,r)=>{G.readFile(e,"utf-8",(n,o)=>{n?r(n):t(o)})});H.exports={LDD_PATH:ke,readFileSync:Le,readFile:ve}});var ce=N((Ke,ae)=>{"use strict";var q=l("child_process"),{isLinux:L,getReport:W}=V(),{LDD_PATH:D,readFile:Z,readFileSync:J}=_(),p,u,K="getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",f="",Q=()=>f||new Promise(e=>{q.exec(K,(t,r)=>{f=t?" ":r,e(f)})}),X=()=>{if(!f)try{f=q.execSync(K,{encoding:"utf8"})}catch{f=" "}return f},d="glibc",Y=/LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i,k="musl",be=e=>e.includes("libc.musl-")||e.includes("ld-musl-"),ee=()=>{let e=W();return e.header&&e.header.glibcVersionRuntime?d:Array.isArray(e.sharedObjects)&&e.sharedObjects.some(be)?k:null},te=e=>{let[t,r]=e.split(/[\r\n]+/);return t&&t.includes(d)?d:r&&r.includes(k)?k:null},re=e=>e.includes("musl")?k:e.includes("GNU C Library")?d:null,Oe=async()=>{if(p!==void 0)return p;p=null;try{let e=await Z(D);p=re(e)}catch{}return p},Re=()=>{if(p!==void 0)return p;p=null;try{let e=J(D);p=re(e)}catch{}return p},oe=async()=>{let e=null;if(L()&&(e=await Oe(),e||(e=ee()),!e)){let t=await Q();e=te(t)}return e},ne=()=>{let e=null;if(L()&&(e=Re(),e||(e=ee()),!e)){let t=X();e=te(t)}return e},xe=async()=>L()&&await oe()!==d,De=()=>L()&&ne()!==d,Se=async()=>{if(u!==void 0)return u;u=null;try{let t=(await Z(D)).match(Y);t&&(u=t[1])}catch{}return u},Ce=()=>{if(u!==void 0)return u;u=null;try{let t=J(D).match(Y);t&&(u=t[1])}catch{}return u},se=()=>{let e=W();return e.header&&e.header.glibcVersionRuntime?e.header.glibcVersionRuntime:null},B=e=>e.trim().split(/\s+/)[1],ie=e=>{let[t,r,n]=e.split(/[\r\n]+/);return t&&t.includes(d)?B(t):r&&n&&r.includes(k)?B(n):null},Me=async()=>{let e=null;if(L()&&(e=await Se(),e||(e=se()),!e)){let t=await Q();e=ie(t)}return e},Ne=()=>{let e=null;if(L()&&(e=Ce(),e||(e=se()),!e)){let t=X();e=ie(t)}return e};ae.exports={GLIBC:d,MUSL:k,family:oe,familySync:ne,isNonGlibcLinux:xe,isNonGlibcLinuxSync:De,version:Me,versionSync:Ne}});var ze={};Pe(ze,{default:()=>$e});var b=l("@yarnpkg/core");var g=l("@yarnpkg/core"),j=l("@yarnpkg/fslib"),w=l("@yarnpkg/fslib"),R=l("@yarnpkg/libzip"),E=l("stream");async function $(e,t,r,n){let{packageLocation:o,packageFs:s}=await U(t,r),{packageLocation:i,packageFs:c}=await U(e,r),m=process.platform==="win32"?"ast-grep.exe":"ast-grep",y=process.platform==="win32"?"sg.exe":"sg",F=await s.readFilePromise(w.ppath.join(o,m));await c.writeFilePromise(w.ppath.join(i,m),F),await c.chmodPromise(w.ppath.join(i,m),493),await c.writeFilePromise(w.ppath.join(i,y),F),await c.chmodPromise(w.ppath.join(i,y),493),n.report.reportInfo(g.MessageName.UNNAMED,"Installed prebuild for @ast-grep/cli")}async function U(e,t){let r=t.storedPackages.get(e.locatorHash);if(!r)throw new Error(`Package for ${g.structUtils.prettyLocator(t.configuration,e)} not found in the project`);return await R.ZipOpenFS.openPromise(async n=>{let o=t.configuration,s=t.configuration.getLinkers(),i={project:t,report:new g.StreamReport({stdout:new E.PassThrough,configuration:o})},c=s.find(F=>F.supportsPackage(r,i));if(!c)throw new Error(`The package ${g.structUtils.prettyLocator(t.configuration,r)} isn't supported by any of the available linkers`);let m=await c.findPackageLocation(r,i),y=new j.CwdFS(m,{baseFs:n});return{packageLocation:m,packageFs:y}},{libzip:await(0,R.getLibzipPromise)()})}var S=ye(ce());async function Ie(){let e=[process.platform,process.arch];return process.platform==="linux"?await(0,S.family)()===S.MUSL?e.push("musl"):process.arch==="arm"?e.push("gnueabihf"):e.push("gnu"):process.platform==="win32"&&e.push("msvc"),`cli-${e.join("-")}`}function Ae(e,t){for(let r of e.storedPackages.values())if(r.scope==="ast-grep"&&r.name===t)return r;return null}async function Ue(e,t){let r=await Ie(),n=Ae(e,r);for(let o of e.storedPackages.values())if(o.scope==="ast-grep"&&o.name==="cli"){if(!n){t.report.reportInfo(b.MessageName.UNNAMED,`Couldn't mutate @ast-grep/cli, couldn't find replacement @ast-grep/${r}`);return}try{await $(o,n,e,t)}catch(s){t.report.reportInfo(b.MessageName.UNNAMED,`Couldn't mutate @ast-grep/cli for ${b.structUtils.stringifyLocator(o)}`),console.error(s)}}}async function le(e,t){await t.report.startTimerPromise("@ast-grep/cli installation",async()=>{await Ue(e,t)})}var h=l("@yarnpkg/core"),a=l("@yarnpkg/fslib"),I=l("@yarnpkg/libzip"),C=class{supports(t,r){return!!t.reference.startsWith("static-ast-grep:")}getLocalPath(t,r){return null}async fetch(t,r){let n=new a.NodeFS,{zipPackage:o}=await this.fetchPrebuild(t,r),s=o.getRealPath();await a.xfs.chmodPromise(s,420);let i=`${r.cache.cacheKey}/${t.locatorHash}`,c=r.cache.getLocatorPath(t,i);if(r.cache.markedFiles.add(c),!c)throw new Error("Assertion failed: Expected the cache path to be available");await a.xfs.mkdirpPromise(a.ppath.dirname(c)),await a.xfs.movePromise(s,c);let m,y=()=>new I.ZipFS(c,{baseFs:n,readOnly:!0}),F=new a.LazyFS(()=>h.miscUtils.prettifySyncErrors(()=>m=y(),ue=>`Failed to open the cache entry for ${h.structUtils.prettyLocator(r.project.configuration,t)}: ${ue}`),a.ppath);return{packageFs:new a.AliasFS(c,{baseFs:F,pathUtils:a.ppath}),releaseFs:()=>{m?.discardAndClose()},prefixPath:h.structUtils.getIdentVendorPath(t),localPath:this.getLocalPath(t,r),checksum:i}}async fetchPrebuild(t,r){let n=await a.xfs.mktempPromise(),o=a.ppath.join(n,"prebuilt.zip"),s=h.structUtils.getIdentVendorPath(t),i=new I.ZipFS(o,{create:!0});return await i.mkdirpPromise(s),await new a.CwdFS(s,{baseFs:i}).writeJsonPromise("package.json",{name:h.structUtils.slugifyLocator(t),bin:{sg:process.platform==="win32"?"sg.exe":"sg","ast-grep":process.platform==="win32"?"ast-grep.exe":"ast-grep"},preferUnplugged:!0}),i.saveAndClose(),{zipPackage:i}}};var P=l("@yarnpkg/core"),pe=async(e,t,r,n,o)=>{if(e.scope==="ast-grep"&&e.name==="cli"){let s=P.structUtils.makeDescriptor(e,P.structUtils.makeRange({protocol:"static-ast-grep:",source:P.structUtils.stringifyDescriptor(e),selector:`ast-grep-cli<${n.range}>`,params:null}));return o.resolveOptions.report.reportInfo(P.MessageName.UNNAMED,`Found @ast-grep/cli dependency in ${P.structUtils.stringifyLocator(r)}, re-routing to static prebuild`),s}return e};var v=l("@yarnpkg/core"),M=class{supportsDescriptor(t,r){return!!t.range.startsWith("static-ast-grep:")}supportsLocator(t,r){return!!t.reference.startsWith("static-ast-grep:")}shouldPersistResolution(t,r){return!1}bindDescriptor(t,r,n){return t}getResolutionDependencies(t,r){return{}}async getCandidates(t,r,n){if(!n.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");return[v.structUtils.makeLocator(v.structUtils.parseIdent("@ast-grep/cli"),t.range)]}async getSatisfying(t,r,n,o){let[s]=await this.getCandidates(t,r,o);return{locators:n.filter(i=>i.locatorHash===s.locatorHash),sorted:!1}}async resolve(t,r){let n=je(t.reference);if(!n)throw new Error(`Could not extract version from ${t.reference}`);let o=await r.resolver.resolve(v.structUtils.parseLocator(`@ast-grep/cli@${n}`),r),s=new Map(o.bin.entries());if(process.platform==="win32")for(let[i,c]of s.entries())s.set(i,`${c}.exe`);return{...t,version:"*",languageName:r.project.configuration.get("defaultLanguageName"),linkType:v.LinkType.HARD,dependencies:o.dependencies,peerDependencies:o.peerDependencies,dependenciesMeta:o.dependenciesMeta,peerDependenciesMeta:o.peerDependenciesMeta,bin:s}}};function je(e){let t=e.match(/<([^>]+)>/);if(!t)return null;let r=t[1];return r.startsWith("npm%3A")?`npm:${r.slice(6)}`:r}var Ee={hooks:{reduceDependency:pe,afterAllInstalled:le},fetchers:[C],resolvers:[M]},$e=Ee;return Fe(ze);})();
return plugin;
}
};
