/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-static-ast-grep",
factory: function (require) {
var plugin=(()=>{var me=Object.create;var O=Object.defineProperty;var fe=Object.getOwnPropertyDescriptor;var de=Object.getOwnPropertyNames;var ge=Object.getPrototypeOf,he=Object.prototype.hasOwnProperty;var l=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,r)=>(typeof require<"u"?require:t)[r]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw new Error('Dynamic require of "'+e+'" is not supported')});var M=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports),ye=(e,t)=>{for(var r in t)O(e,r,{get:t[r],enumerable:!0})},A=(e,t,r,o)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of de(t))!he.call(e,n)&&n!==r&&O(e,n,{get:()=>t[n],enumerable:!(o=fe(t,n))||o.enumerable});return e};var Fe=(e,t,r)=>(r=e!=null?me(ge(e)):{},A(t||!e||!e.__esModule?O(r,"default",{value:e,enumerable:!0}):r,e)),Pe=e=>A(O({},"__esModule",{value:!0}),e);var V=M((Ze,T)=>{"use strict";var z=()=>process.platform==="linux",D=null,we=()=>{if(!D)if(z()&&process.report){let e=process.report.excludeNetwork;process.report.excludeNetwork=!0,D=process.report.getReport(),process.report.excludeNetwork=e}else D={};return D};T.exports={isLinux:z,getReport:we}});var _=M((Je,H)=>{"use strict";var G=l("fs"),ke="/usr/bin/ldd",Le=e=>G.readFileSync(e,"utf-8"),ve=e=>new Promise((t,r)=>{G.readFile(e,"utf-8",(o,n)=>{o?r(o):t(n)})});H.exports={LDD_PATH:ke,readFileSync:Le,readFile:ve}});var ce=M((Ke,ae)=>{"use strict";var q=l("child_process"),{isLinux:L,getReport:W}=V(),{LDD_PATH:x,readFile:Z,readFileSync:J}=_(),p,u,K="getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true",f="",Q=()=>f||new Promise(e=>{q.exec(K,(t,r)=>{f=t?" ":r,e(f)})}),X=()=>{if(!f)try{f=q.execSync(K,{encoding:"utf8"})}catch{f=" "}return f},d="glibc",Y=/LIBC[a-z0-9 \-).]*?(\d+\.\d+)/i,k="musl",be=e=>e.includes("libc.musl-")||e.includes("ld-musl-"),ee=()=>{let e=W();return e.header&&e.header.glibcVersionRuntime?d:Array.isArray(e.sharedObjects)&&e.sharedObjects.some(be)?k:null},te=e=>{let[t,r]=e.split(/[\r\n]+/);return t&&t.includes(d)?d:r&&r.includes(k)?k:null},re=e=>e.includes("musl")?k:e.includes("GNU C Library")?d:null,Oe=async()=>{if(p!==void 0)return p;p=null;try{let e=await Z(x);p=re(e)}catch{}return p},Re=()=>{if(p!==void 0)return p;p=null;try{let e=J(x);p=re(e)}catch{}return p},ne=async()=>{let e=null;if(L()&&(e=await Oe(),e||(e=ee()),!e)){let t=await Q();e=te(t)}return e},oe=()=>{let e=null;if(L()&&(e=Re(),e||(e=ee()),!e)){let t=X();e=te(t)}return e},De=async()=>L()&&await ne()!==d,xe=()=>L()&&oe()!==d,Se=async()=>{if(u!==void 0)return u;u=null;try{let t=(await Z(x)).match(Y);t&&(u=t[1])}catch{}return u},Ce=()=>{if(u!==void 0)return u;u=null;try{let t=J(x).match(Y);t&&(u=t[1])}catch{}return u},se=()=>{let e=W();return e.header&&e.header.glibcVersionRuntime?e.header.glibcVersionRuntime:null},B=e=>e.trim().split(/\s+/)[1],ie=e=>{let[t,r,o]=e.split(/[\r\n]+/);return t&&t.includes(d)?B(t):r&&o&&r.includes(k)?B(o):null},Ne=async()=>{let e=null;if(L()&&(e=await Se(),e||(e=se()),!e)){let t=await Q();e=ie(t)}return e},Me=()=>{let e=null;if(L()&&(e=Ce(),e||(e=se()),!e)){let t=X();e=ie(t)}return e};ae.exports={GLIBC:d,MUSL:k,family:ne,familySync:oe,isNonGlibcLinux:De,isNonGlibcLinuxSync:xe,version:Ne,versionSync:Me}});var ze={};ye(ze,{default:()=>$e});var b=l("@yarnpkg/core");var g=l("@yarnpkg/core"),j=l("@yarnpkg/fslib"),w=l("@yarnpkg/fslib"),R=l("@yarnpkg/libzip"),E=l("stream");async function $(e,t,r,o){let{packageLocation:n,packageFs:a}=await U(t,r),{packageLocation:i,packageFs:c}=await U(e,r),m=process.platform==="win32"?"ast-grep.exe":"ast-grep",F=process.platform==="win32"?"sg.exe":"sg",P=await a.readFilePromise(w.ppath.join(n,m));await c.writeFilePromise(w.ppath.join(i,m),P),await c.chmodPromise(w.ppath.join(i,m),493),await c.writeFilePromise(w.ppath.join(i,F),P),await c.chmodPromise(w.ppath.join(i,F),493),o.report.reportInfo(g.MessageName.UNNAMED,"Installed prebuild for @ast-grep/cli")}async function U(e,t){let r=t.storedPackages.get(e.locatorHash);if(!r)throw new Error(`Package for ${g.structUtils.prettyLocator(t.configuration,e)} not found in the project`);return await R.ZipOpenFS.openPromise(async o=>{let n=t.configuration,a=t.configuration.getLinkers(),i={project:t,report:new g.StreamReport({stdout:new E.PassThrough,configuration:n})},c=a.find(P=>P.supportsPackage(r,i));if(!c)throw new Error(`The package ${g.structUtils.prettyLocator(t.configuration,r)} isn't supported by any of the available linkers`);let m=await c.findPackageLocation(r,i),F=new j.CwdFS(m,{baseFs:o});return{packageLocation:m,packageFs:F}},{libzip:await(0,R.getLibzipPromise)()})}var S=Fe(ce());async function Ie(){let e=[process.platform,process.arch];return process.platform==="linux"?await(0,S.family)()===S.MUSL?e.push("musl"):process.arch==="arm"?e.push("gnueabihf"):e.push("gnu"):process.platform==="win32"&&e.push("msvc"),`cli-${e.join("-")}`}function Ae(e,t){for(let r of e.storedPackages.values())if(r.scope==="ast-grep"&&r.name===t)return r;return null}async function Ue(e,t){let r=await Ie(),o=Ae(e,r);for(let n of e.storedPackages.values())if(n.scope==="ast-grep"&&n.name==="cli"){if(!o){t.report.reportInfo(b.MessageName.UNNAMED,`Couldn't mutate @ast-grep/cli, couldn't find replacement @ast-grep/${r}`);return}try{await $(n,o,e,t)}catch(a){t.report.reportInfo(b.MessageName.UNNAMED,`Couldn't mutate @ast-grep/cli for ${b.structUtils.stringifyLocator(n)}`),console.error(a)}}}async function le(e,t){await t.report.startTimerPromise("@ast-grep/cli installation",async()=>{await Ue(e,t)})}var h=l("@yarnpkg/core"),s=l("@yarnpkg/fslib"),I=l("@yarnpkg/libzip"),C=class{supports(t,r){return!!t.reference.startsWith("static-ast-grep:")}getLocalPath(t,r){return null}async fetch(t,r){let o=new s.NodeFS,{zipPackage:n}=await this.fetchPrebuild(t,r),a=n.getRealPath();await s.xfs.chmodPromise(a,420);let i=`${r.cache.cacheKey}/${t.locatorHash}`,c=r.cache.getLocatorPath(t,i);if(r.cache.markedFiles.add(c),!c)throw new Error("Assertion failed: Expected the cache path to be available");await s.xfs.mkdirpPromise(s.ppath.dirname(c)),await s.xfs.movePromise(a,c);let m,F=()=>new I.ZipFS(c,{baseFs:o,readOnly:!0}),P=new s.LazyFS(()=>h.miscUtils.prettifySyncErrors(()=>m=F(),ue=>`Failed to open the cache entry for ${h.structUtils.prettyLocator(r.project.configuration,t)}: ${ue}`),s.ppath);return{packageFs:new s.AliasFS(c,{baseFs:P,pathUtils:s.ppath}),releaseFs:()=>{m?.discardAndClose()},prefixPath:h.structUtils.getIdentVendorPath(t),localPath:this.getLocalPath(t,r),checksum:i}}async fetchPrebuild(t,r){let o=await s.xfs.mktempPromise(),n=s.ppath.join(o,"prebuilt.zip"),a=h.structUtils.getIdentVendorPath(t),i=new I.ZipFS(n,{create:!0});return await i.mkdirpPromise(a),await new s.CwdFS(a,{baseFs:i}).writeJsonPromise("package.json",{name:h.structUtils.slugifyLocator(t),bin:{sg:"sg","ast-grep":"ast-grep"},preferUnplugged:!0}),i.saveAndClose(),{zipPackage:i}}};var y=l("@yarnpkg/core"),pe=async(e,t,r,o,n)=>{if(e.scope==="ast-grep"&&e.name==="cli"){let a=y.structUtils.makeDescriptor(e,y.structUtils.makeRange({protocol:"static-ast-grep:",source:y.structUtils.stringifyDescriptor(e),selector:`ast-grep-cli<${o.range}>`,params:null}));return n.resolveOptions.report.reportInfo(y.MessageName.UNNAMED,`Found @ast-grep/cli dependency in ${y.structUtils.stringifyLocator(r)}, re-routing to static prebuild`),a}return e};var v=l("@yarnpkg/core"),N=class{supportsDescriptor(t,r){return!!t.range.startsWith("static-ast-grep:")}supportsLocator(t,r){return!!t.reference.startsWith("static-ast-grep:")}shouldPersistResolution(t,r){return!1}bindDescriptor(t,r,o){return t}getResolutionDependencies(t,r){return{}}async getCandidates(t,r,o){if(!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");return[v.structUtils.makeLocator(v.structUtils.parseIdent("@ast-grep/cli"),t.range)]}async getSatisfying(t,r,o,n){let[a]=await this.getCandidates(t,r,n);return{locators:o.filter(i=>i.locatorHash===a.locatorHash),sorted:!1}}async resolve(t,r){let o=je(t.reference);if(!o)throw new Error(`Could not extract version from ${t.reference}`);let n=await r.resolver.resolve(v.structUtils.parseLocator(`@ast-grep/cli@${o}`),r);return{...t,version:"*",languageName:r.project.configuration.get("defaultLanguageName"),linkType:v.LinkType.HARD,dependencies:n.dependencies,peerDependencies:n.peerDependencies,dependenciesMeta:n.dependenciesMeta,peerDependenciesMeta:n.peerDependenciesMeta,bin:n.bin}}};function je(e){let t=e.match(/<([^>]+)>/);if(!t)return null;let r=t[1];return r.startsWith("npm%3A")?`npm:${r.slice(6)}`:r}var Ee={hooks:{reduceDependency:pe,afterAllInstalled:le},fetchers:[C],resolvers:[N]},$e=Ee;return Pe(ze);})();
return plugin;
}
};
